/**
 * @author Tomas Polasek, David Hrusa
 * @date 1.14.2020
 * @version 1.0
 * @brief Tree statistics wrapper.
 */

#ifndef TREE_RENDER_SYSTEM_RT_H
#define TREE_RENDER_SYSTEM_RT_H

#include "TreeUtils.h"
#include "TreeRuntimeMetaData.h"
#include "TreeCamera.h"
#include "TreeRenderer.h"
#include "TreeRenderSystem.h"

// Forward declaration.
namespace treert
{ class RayTracer; using RayTracerPtr = treeutil::WrapperPtrT<RayTracer>; }

namespace treerndr
{

// Forward declaration of internal implementation:
namespace impl
{ struct RenderSystemRTImpl; }

/// @brief Renderer used for ray tracing.
class RenderSystemRT : public RenderSystem
{
public:
    /// Name of this renderer.
    static constexpr auto RENDERER_NAME{ "RayTracing" };

    /// @brief Initialize the render system.
    RenderSystemRT();
    /// @brief Clean-up and destroy.
    virtual ~RenderSystemRT();

    /// @brief Initialize the renderer and create any required resources.
    virtual void initialize() override final;
    /// @brief Render current configuration of the scene.
    virtual void render(treescene::CameraState &camera,
        treescene::TreeScene &scene) override final;
    /// @brief Reload all shaders for this renderer.
    virtual void reloadShaders() override final;

    /// @brief Access visualization parameters.
    virtual VisualizationParameters &parameters() override final;

    /// @brief Generate ray tracing compatible context from current state.
    static RenderContext generateRayTracingContext(
        treescene::CameraState &camera, treescene::TreeScene &scene);

    /**
     * @brief Construct a ray-tracer with added tree reconstruction model.
     *
     * @param tree Tree to add to the ray-tracer scene.
     * @param treeScale Scale of the tree to use.
     * @return Returns pointer to the ray-tracer with initialized scene.
     */
    static treert::RayTracerPtr prepareTreeRayTracer(const treeio::ArrayTree &inputTree,
        float treeScale = 1.0f);
private:
    /// Internal implementation.
    std::shared_ptr<impl::RenderSystemRTImpl> mImpl{ };
protected:
}; // class RenderSystemRT

} // namespace treerndr

namespace treert
{

namespace impl
{

/// @brief Internal implementation of the RayTracer.
class RayTracerImpl;

} // namespace impl

/// @brief Scene renderable by the ray tracer.
class RayTracerScene : public treeutil::PointerWrapper<RayTracerScene>
{
public:
    /// @brief Pointer to a scene instance.
    using InstancePtr = treerndr::MeshInstancePtr;
    /// @brief storage used for unique instance storage.
    using InstanceStorage = std::map<std::string, InstancePtr>;

    /// @brief Initialize an empty scene.
    RayTracerScene();
    /// @brief Clean up and destroy.
    ~RayTracerScene();

    // Scene Manipulators:

    /**
     * Add given instance to the scene. Automatically detects duplicates.
     *
     * @param instance Instance to add.
     * @return Returns true if the instance was newly added to the scene.
     * @warning Automatically sets the dirty flag if necessary.
     */
    bool addInstance(const InstancePtr &instance);

    /**
     * Remove given instance to the scene.
     *
     * @param instance Instance to remove.
     * @return Returns true if the instance has been removed. Returns
     *  false if no such instance was found in this scene.
     * @warning Automatically sets the dirty flag if necessary.
     */
    bool removeInstance(const InstancePtr &instance);

    /// @brief Reset the scene to default (empty) state.
    void reset();

    // Scene accessors:

    /// @brief Get container with instances currently within this scene.
    const InstanceStorage &instances() const;

    // Utilities:

    /// @brief Set this scene as dirty, requiring acceleration structure rebuild.
    void setDirty();

    /// @brief Set this scene as not dirty.
    void resetDirty();

    /// @brief Export all instances in this scene into separate OBJ files in given path.
    std::size_t exportInstances(const std::string &basePath,
        const treerndr::RenderContext &ctx) const;
private:
    // Allow access to internal elements by the ray-tracer.
    friend class impl::RayTracerImpl;

    /// Instances currently within the scene.
    InstanceStorage mInstances{ };

    /// Has the scene configuration changed?
    bool mDirty{ true };
    /// Names of instances added since the last resetDirty().
    std::set<std::string> mAdded{ };
    /// Names of instances removed since the last resetDirty().
    std::set<std::string> mRemoved{ };
protected:
}; // class RayTracerScene

/// @brief Output modalities generated by the RayTracer.
enum class TracingModality
{
    /// @brief Trace shadows.
    Shadow,
    /// @brief Trace normals.
    Normal,
    /// @brief Trace depths.
    Depth,
    /// @brief Trace number of triangles intersected.
    TriangleCount,
    /// @brief Trace time spent inside the volume.
    Volume,
}; // enum class TracingModality

/// @brief Get tracing modality from index.
TracingModality tracingModalityFromIdx(std::size_t idx);
/// @brief Convert tracing modality to its name.
std::string tracingModalityName(TracingModality modality);
/// @brief Convert modality to its index.
std::size_t tracingModalityIdx(TracingModality modality);

/// @brief Convert normal display modality into ray tracing equivalent.
TracingModality displayModalityToTracing(const treerndr::RendererModality &modality);

/// @brief Simple ray-tracer usable for the rendering of an internal scene.
class RayTracer : public treeutil::PointerWrapper<RayTracer>
{
public:
    /// @brief Base class for the output modality buffer.
    struct OutputModalityBase
    {
        /// @brief Initialize this modality for given buffer size.
        virtual void initialize(std::size_t w, std::size_t h, std::size_t s) = 0;

        /// @brief Deallocate and reset this modality.
        virtual void reset() = 0;

        /// @brief Get OpenGL type of this buffer.
        virtual GLenum glType() const = 0;

        /// @brief Get OpenGL texture filled with data from this buffer.
        virtual treerndr::TextureBufferPtr glTexture() const = 0;

        /// @brief Get OpenGL normalized texture filled with data from this buffer.
        virtual treerndr::TextureBufferPtr glNormalizedTexture(bool flipYAxis) const = 0;

        /// @brief Save content of this modality to given path.
        virtual void exportToFile(const std::string &outputPath) const = 0;

        /// @brief Access the buffer data.
        virtual const void *buffer() const = 0;

        /// @brief Get size of a single element within the buffer.
        virtual const std::size_t elementSize() const = 0;

        /// @brief Is this modality initialized and valid?
        inline bool valid() const;

        /// @brief Is this modality initialized and valid?
        inline operator bool() const;

        /// Width of the buffer in pixels.
        std::size_t width{ 0u };
        /// Height of the buffer in pixels.
        std::size_t height{ 0u };
        /// Number of samples per pixel.
        std::size_t samples{ 1u };
    }; // struct OutputModalityBase

    /// @brief Wrapper for a single rendered output modality buffer.
    template <typename BT>
    struct OutputModality : public OutputModalityBase
    {
        /// @brief Type of data contained within the buffer.
        using BufferT = BT;

        /// @brief Initialize default (empty) modality.
        OutputModality();

        /// @brief Initialize this modality for given buffer size.
        OutputModality(std::size_t w, std::size_t h, std::size_t s);

        /// @brief Initialize this modality for given buffer size.
        virtual void initialize(std::size_t w, std::size_t h, std::size_t s) override final;

        /// @brief Deallocate and reset this modality.
        virtual void reset() override final;

        /// @brief Get OpenGL type of this buffer.
        virtual GLenum glType() const override final;

        /// @brief Get OpenGL texture filled with data from this buffer.
        virtual treerndr::TextureBufferPtr glTexture() const override final;

        /// @brief Get OpenGL normalized texture filled with data from this buffer.
        virtual treerndr::TextureBufferPtr glNormalizedTexture(bool flipYAxis) const override final;

        /// @brief Save content of this modality to given path.
        virtual void exportToFile(const std::string &outputPath) const override final;

        /// @brief Access the buffer data.
        virtual const void *buffer() const override final;

        /// @brief Get size of a single element within the buffer.
        virtual const std::size_t elementSize() const override final;

        /// @brief Access element at position (x, y, s).
        BT &element(std::size_t x, std::size_t y, std::size_t s = 0);
        /// @brief Access element at position (x, y, s).
        const BT &element(std::size_t x, std::size_t y, std::size_t s = 0) const;

        /// Buffer containing the raw data - compatible with OpenGL.
        std::vector<BT> dataBuffer{ };
    }; // struct OutputModality

    // Modality Types:

    /// @brief Shadow modality holder type.
    using ShadowModality = OutputModality<float>;
    /// @brief Normal modality holder type.
    using NormalModality = OutputModality<Vector3D>;
    /// @brief Depth modality holder type.
    using DepthModality = OutputModality<float>;
    /// @brief Triangle count modality holder type.
    using TriangleCountModality = OutputModality<uint32_t>;
    /// @brief Volume modality holder type.
    using VolumeModality = OutputModality<float>;

    /// @brief Initialize the ray-tracer with empty scene.
    RayTracer();
    /// @brief Clean up and destroy.
    ~RayTracer();

    // Configuration Manipulators:

    /// @brief Reset the current configuration of this ray tracer.
    void reset();

    /// @brief Access the internal scene which is being rendered.
    RayTracerScene &scene();

    /// @brief Enable tracing of only given modalities.
    void traceModalities(const std::initializer_list<TracingModality> &types, bool resetOthers = true);

    /// @brief Enable tracing of only given modalities.
    void traceModalities(const std::vector<TracingModality> &types, bool resetOthers = true);

    /// @brief Enable tracing of only single given modality.
    void traceModalities(TracingModality type, bool resetOthers = true);

    /// @brief Set verbosity for render progress reporting.
    void setVerbose(bool verbose = true);

    /// @brief Set number of samples per pixel.
    void setSampling(std::size_t samples = 1u);

    /// @brief Generate a simplified context usable in traceRays(), using perspective camera.
    treerndr::RenderContext generatePerspectiveContext(
        std::size_t viewportWidth, std::size_t viewportHeight,
        const Vector3D &cameraPosition, const Vector3D &cameraTarget = { },
        float cameraFov = treescene::CameraState::DEFAULT_CAMERA_FOV,
        float cameraNear = treescene::CameraState::PERSPECTIVE_CAMERA_NEAR_PLANE,
        float cameraFar = treescene::CameraState::PERSPECTIVE_CAMERA_FAR_PLANE,
        const Vector3D &lightPosition = { });

    /// @brief Generate a simplified context usable in traceRays(), using orthographic camera.
    treerndr::RenderContext generateOrthoContext(
        std::size_t viewportWidth, std::size_t viewportHeight,
        const Vector3D &cameraPosition, const Vector3D &cameraTarget = { },
        float cameraFov = treescene::CameraState::DEFAULT_CAMERA_FOV,
        float cameraNear = treescene::CameraState::ORTHOGRAPHIC_CAMERA_NEAR_PLANE,
        float cameraFar = treescene::CameraState::ORTHOGRAPHIC_CAMERA_FAR_PLANE,
        const Vector3D &lightPosition = { });

    // Rendering:

    /**
     * @brief Render current configuration of the internal scene
     *  and store resulting output modalities to be accessed later.
     *
     * @param input Current state of the application.
     * @param ctx Rendering context used to determine rendering
     *  requirements.
     */
    void traceRays(const treerndr::RenderContext &ctx);

    // Result access:

    /// @brief Access the shadow output modality. Buffer may be invalidated on other operations!
    const ShadowModality &shadowModality() const;
    /// @brief Access the normal output modality. Buffer may be invalidated on other operations!
    const NormalModality &normalModality() const;
    /// @brief Access the depth output modality. Buffer may be invalidated on other operations!
    const DepthModality &depthModality() const;
    /// @brief Access the triangle count output modality. Buffer may be invalidated on other operations!
    const TriangleCountModality &triangleCountModality() const;
    /// @brief Access the volume output modality. Buffer may be invalidated on other operations!
    const VolumeModality &volumeModality() const;

    /// @brief Access given type of output modality. Buffer may be invalidated on other operations!
    const OutputModalityBase &modality(TracingModality type) const;

    /// @brief Get list of currently active modalities.
    std::vector<TracingModality> activeModalities() const;
private:
    /// Internal implementation of the ray tracer.
    std::shared_ptr<impl::RayTracerImpl> mImpl{ };
protected:
}; // class RayTracer

} // namespace treert

// Template implementation begin.

namespace treerndr
{

} // namespace treerndr

namespace treert
{

inline bool RayTracer::OutputModalityBase::valid() const
{ return width != 0u && height != 0u && samples != 0u && buffer(); }

inline RayTracer::OutputModalityBase::operator bool() const
{ return valid(); }

template <typename BT>
RayTracer::OutputModality<BT>::OutputModality()
{ }

template <typename BT>
RayTracer::OutputModality<BT>::OutputModality(std::size_t w, std::size_t h, std::size_t s)
{ initialize(w, h, s); }

template <typename BT>
void RayTracer::OutputModality<BT>::initialize(std::size_t w, std::size_t h, std::size_t s)
{ dataBuffer.resize(w * h * s * s); width = w; height = h; samples = s; }

template <typename BT>
void RayTracer::OutputModality<BT>::reset()
{ dataBuffer = { }; width = 0u; height = 0u; samples = 0u; }

template <typename BT>
GLenum RayTracer::OutputModality<BT>::glType() const
{ return treeutil::typeToGLType<BT>(); }

template <typename BT>
treerndr::TextureBufferPtr RayTracer::OutputModality<BT>::glTexture() const
{
    // TODO - Caching, optimization?
    return treerndr::TextureBuffer::instantiate(dataBuffer, width, height);
}

template <typename BT>
treerndr::TextureBufferPtr RayTracer::OutputModality<BT>::glNormalizedTexture(bool flipYAxis) const
{
    if (flipYAxis)
    {
        std::vector<BT> flippedData{ }; flippedData.resize(dataBuffer.size());
        for (std::size_t yPos = 0u; yPos < height; ++yPos)
        { std::memcpy(&flippedData[yPos * width], &dataBuffer[(height - yPos - 1u) * width], width * sizeof(BT)); }
        return treerndr::TextureBuffer::createNormalized(flippedData, width, height);
    }
    else
    { return treerndr::TextureBuffer::createNormalized(dataBuffer, width, height); }
}

template <typename BT>
void RayTracer::OutputModality<BT>::exportToFile(const std::string &outputPath) const
{
    treeio::ImageExporter exporter{ };
    exporter.loadImage(dataBuffer, width, height, true);
    exporter.exportImage(outputPath);
}

template <typename BT>
const void *RayTracer::OutputModality<BT>::buffer() const
{ return dataBuffer.data(); }

template <typename BT>
const std::size_t RayTracer::OutputModality<BT>::elementSize() const
{ return sizeof(BT); }

template <typename BT>
BT &RayTracer::OutputModality<BT>::element(std::size_t x, std::size_t y, std::size_t s)
{ return dataBuffer[s + x * samples + y * samples * width]; }

template <typename BT>
const BT &RayTracer::OutputModality<BT>::element(std::size_t x, std::size_t y, std::size_t s) const
{ return dataBuffer[s + x * samples + y * samples * width]; }

} // namespace treert

// Template implementation end.

#endif // TREE_RENDER_SYSTEM_RT_H
